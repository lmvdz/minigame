<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
	<title>lmvdzandebot - minigame</title>
	<!-- Link to the last version of BabylonJS -->
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <!-- Link to the last version of BabylonJS loaders to enable loading filetypes such as .gltf -->
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <!-- Link to pep.js to ensure pointer events work consistently in all browsers -->
	<script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
	<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
	<script src="/assets/JS/post.js" type="text/javascript"></script>
	<script src="/assets/JS/setupAccess.js" type="text/javascript"></script>
    <script src="/assets/JS/removeHash.js" type="text/javascript"></script>
</head>
<body>
	<div id="app">
		<span v-if="twitchUserData !== null">
			<img :src="twitchUserData.profile_image_url" width="128"/>
			<div> {{ twitchUserData.login }} </div>
			<div v-if="!botConnected">
				<button  @click="connectBot()">Connect Bot To Your Channel</button>
				<span style="color: red;">Bot Not Connected</span>
			</div>
			<div v-else>
				<button @click="disconnectBot()">Disconnect Bot</button>
				<span style="color: green;">Bot Connected</span>
			</div>
			<span v-if="connectBotResponse !== ''"> {{ connectBotResponse }}</span>
			<span v-if="disconnectBotResponse !== ''"> {{ disconnectBotResponse }}</span>
			<div v-if="botCommands.length > 0">
				<h3>commands</h3>
				<ul>
					<li v-for="command in botCommands">
						{{ command }}
					</li>
				</ul>
			</div>
		</span>
	</div>
	<canvas id="renderCanvas"></canvas>
	<script type="text/javascript">
		var app = new Vue({
			el: '#app',
			data: {
				twitchUserData: null,
				channel: null,
				botConnected: false,
				connectBotResponse: '',
				disconnectBotResponse: '',
				botCommands: []
			},
			methods: {
				disconnectBot() {
					let that = this;
					return axios.post('/bot/' + this.twitchUserData.login + "/disconnect").then(function(response) {
						that.disconnectBotResponse = response.data;
						setTimeout(function() {
							that.disconnectBotResponse = "";
							that.botChannelStatus().then(function(response) {
								that.botConnected = response.data;
							}).catch(function(error) {
								that.botConnected = false;
							});
						}, 1000);
					}).catch(function(error) {
						console.error(error);
					});
				},	
				getBotCommands() {
					return axios.get('/bot/commands');
				},
				botChannelStatus() {
					return axios.get('/bot/' + this.twitchUserData.login + "/status");
				},
				createChannel() {
					return axios.post('/bot/' + this.twitchUserData.login);
				},	
				getChannel() {
					return axios.get('/bot/' + this.twitchUserData.login);
				},
				connectBot() {
					let that = this;
					return axios.post('/bot/' + this.twitchUserData.login + "/connect").then(function(response) {
						that.connectBotResponse = response.data;
						setTimeout(function() {
							that.connectBotResponse = "";
							that.botChannelStatus().then(function(response) {
								that.botConnected = response.data;
							}).catch(function(error) {
								that.botConnected = false;
							});
						}, 1000);
					}).catch(function(error) {
						console.error(error);
					});
				},
				getTwitchUserInfo() {
					let that = this;
					return axios.get('/user');
				},
				validate() {
					return axios.get('/validate');
				}

			},
			mounted() {
				window.setupAccess();
				
			},
			created() {
				let that = this;
				axios.defaults.headers.common['Authorization'] = 'Bearer ' + window.localStorage.getItem('access_token');
				this.validate().then(function(response) {

					// var canvas = document.getElementById('renderCanvas');
					// var engine = new BABYLON.Engine(canvas, true);

					// var createScene = function() {
					//     // Create a basic BJS Scene object.
					//     var scene = new BABYLON.Scene(engine);

					//     // Create a FreeCamera, and set its position to (x:0, y:5, z:-10).
					//     var camera = new BABYLON.FlyCamera('camera', new BABYLON.Vector3(0, 5,-10), scene);

					//     // Target the camera to scene origin.
					//     camera.setTarget(BABYLON.Vector3.Zero());

					//     // Attach the camera to the canvas.
					//     camera.attachControl(canvas, true);

					//     // Create a basic light, aiming 0,1,0 - meaning, to the sky.
					//     var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0,1,0), scene);

					//     // // Create a built-in "sphere" shape. 
					//     // var sphere = BABYLON.MeshBuilder.CreateSphere('sphere', {segments:16, diameter:2}, scene);

					//     // // Move the sphere upward 1/2 of its height.
					//     // sphere.position.y = 1;

					//     // // Create a built-in "ground" shape.
					//     // var ground = BABYLON.MeshBuilder.CreateGround('ground1', {height:6, width:6, subdivisions: 2}, scene);

					//     var box1 = BABYLON.Mesh.CreateBox("Box1", 1.0, scene);
					// 	// var box1animation = BABYLON.Animation.CreateAndStartAnimation('boxscale', box1, 'scaling.x', 30, 120, 1.0, 1.5);
					//     // Return the created scene.
					//     return scene;
					// }
					// var scene = createScene();

					// engine.runRenderLoop(function() {
					//     scene.render();
					// });
					// window.addEventListener('resize', function() {
					//     engine.resize();
					// });
				}).catch(function(error) {
					console.error(error);
				});
				this.getTwitchUserInfo().then(function(data) {
					that.twitchUserData = data.data.data[0];
					that.getChannel().then(function(response) {
						that.channel = response.data;
					}).catch(function(error) {
						that.createChannel().then(function(response) {
							that.channel = response.data;
						}).catch(function(error) {
							console.error(error);
						});
					}).then(function() {
						that.botChannelStatus().then(function(response) {
							that.botConnected = response.data;
						}).catch(function(error) {
							that.botConnected = false;
						});
					}).then(function() {
						that.getBotCommands().then(function(response) {
							that.botCommands = response.data;
						}).catch(function(error) {
							console.error(erorr);
						})
					})
				}).catch(function(error) {
					console.error(error);
				});
			}
		});
	</script>
</body>
<style type="text/css">
	html, body {
        overflow: hidden;
        width   : 100%;
        height  : 100%;
        margin  : 0;
        padding : 0;
    }

    #renderCanvas {
        width   : 100%;
        height  : 100%;
        touch-action: none;
    }
</style>
</html>